// WaveFilter.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <iostream>
#include <fstream>
#include <string>
#include <ctime>
#include <iomanip>

using namespace std;

/*
* Filter Coefficients (C Source) generated by the Filter Design and Analysis Tool
* Generated by MATLAB(R) 8.1 and the Signal Processing Toolbox 6.19.
* Generated on: 05-Apr-2014 17:31:07
*/

/*
* Discrete-Time FIR Filter (real)
* -------------------------------
* Filter Structure  : Direct-Form FIR
* Filter Length     : 44
* Stable            : Yes
* Linear Phase      : Yes (Type 2)
*/

/* General type conversion for MATLAB generated C-code  */
/*
* Filter Coefficients (C Source) generated by the Filter Design and Analysis Tool
* Generated by MATLAB(R) 8.1 and the Signal Processing Toolbox 6.19.
* Generated on: 05-Apr-2014 17:41:27
*/

/*
* Discrete-Time FIR Filter (real)
* -------------------------------
* Filter Structure  : Direct-Form FIR
* Filter Length     : 137
* Stable            : Yes
* Linear Phase      : Yes (Type 1)
*/

/* General type conversion for MATLAB generated C-code  */
const int NB = 137;
const double B[137] = {
	-0.0006185162497269, 7.568414049548e-05, 0.0001965558981423, 0.0003997931130463,
	0.0006862445600592, 0.001053489588625, 0.001494591755479, 0.001996256994847,
	0.002538858740086, 0.003095926532426, 0.003635478708176, 0.004120854537722,
	0.004513471118365, 0.004774628409801, 0.004869320883303, 0.004768322085719,
	0.004452288395026, 0.003913480732358, 0.003158466502556, 0.002209277067217,
	0.001103718721894, -0.0001056309384714, -0.001353044452619, -0.002563520522116,
	-0.003656605305295, -0.004552055592415, -0.00517527175452, -0.005463400892409,
	-0.005370698267587, -0.004874028107511, -0.003976041357131, -0.002708422410121,
	-0.001131408547621, 0.0006666985615024, 0.002574527087857, 0.004462171740696,
	0.006189970010766, 0.007615730766747, 0.008606387231578, 0.009046003055253,
	0.008849907428206, 0.007967651947919, 0.006393168556394, 0.004171031154925,
	0.001393649676638, -0.001795912447606, -0.005211611554685, -0.008630465296671,
	-0.01180484898935, -0.01447457651721, -0.01638277485818, -0.01729072257996,
	-0.01699420568503, -0.01533723223028, -0.01222499804373, -0.007632822510898,
	-0.001611774132789, 0.005708894250422, 0.01412620379003, 0.02336936604219,
	0.03311162976807, 0.04298572399223, 0.052601164972, 0.06156405745528,
	0.06949716705632, 0.07605986079018, 0.08096603927632, 0.08399967674925,
	0.08502607497493, 0.08399967674925, 0.08096603927632, 0.07605986079018,
	0.06949716705632, 0.06156405745528, 0.052601164972, 0.04298572399223,
	0.03311162976807, 0.02336936604219, 0.01412620379003, 0.005708894250422,
	-0.001611774132789, -0.007632822510898, -0.01222499804373, -0.01533723223028,
	-0.01699420568503, -0.01729072257996, -0.01638277485818, -0.01447457651721,
	-0.01180484898935, -0.008630465296671, -0.005211611554685, -0.001795912447606,
	0.001393649676638, 0.004171031154925, 0.006393168556394, 0.007967651947919,
	0.008849907428206, 0.009046003055253, 0.008606387231578, 0.007615730766747,
	0.006189970010766, 0.004462171740696, 0.002574527087857, 0.0006666985615024,
	-0.001131408547621, -0.002708422410121, -0.003976041357131, -0.004874028107511,
	-0.005370698267587, -0.005463400892409, -0.00517527175452, -0.004552055592415,
	-0.003656605305295, -0.002563520522116, -0.001353044452619, -0.0001056309384714,
	0.001103718721894, 0.002209277067217, 0.003158466502556, 0.003913480732358,
	0.004452288395026, 0.004768322085719, 0.004869320883303, 0.004774628409801,
	0.004513471118365, 0.004120854537722, 0.003635478708176, 0.003095926532426,
	0.002538858740086, 0.001996256994847, 0.001494591755479, 0.001053489588625,
	0.0006862445600592, 0.0003997931130463, 0.0001965558981423, 7.568414049548e-05,
	-0.0006185162497269
};

struct wave_header {
	char ChunkID[4];
	unsigned int ChunkSize;
	char Format[4];
	char Subchunk1ID[4];
	unsigned int Subchunk1Size;
	unsigned short AudioFormat;
	unsigned short NumChannels;
	unsigned int SampleRate;
	unsigned int ByteRate;
	unsigned short BlockAlign;
	unsigned short BitsPerSample;
	char Subchunk2ID[4];
	unsigned int Subchunk2Size;
};

void xiir_filter(short* x, short* y, short sample)
{
	// Shift samples right
	for (int i = NB - 1; i > 0; i--) {
		x[i] = x[i - 1];
		y[i] = y[i - 1];
	}
	x[0] = sample;
	y[0] = sample;

	// Apply the filter
	short temp = 0;
	for (int i = 0; i < NB; i++) {
		temp += (short)((double)x[i] * B[i]);
	}
	y[0] = temp;
}

int checkHeader(wave_header header)
{
	// Error checks
	if (string(header.ChunkID, 4).compare("RIFF")) {
		cerr << "ChunkID was \"" << string(header.ChunkID, 4) << "\" not \"RIFF\"" << endl;
		return 1;
	} else if (string(header.Format, 4).compare("WAVE")) {
		cerr << "Format was \"" << string(header.Format, 4) << "\" not \"WAVE\"" << endl;
		return 2;
	} else if (string(header.Subchunk1ID, 4).compare("fmt ")) {
		cerr << "Subchunk1ID was \"" << string(header.Subchunk1ID, 4) << "\" not \"fmt \"" << endl;
		return 3;
	} else if (header.AudioFormat != 1) {
		cerr << "AudioFormat was \"" << header.AudioFormat << "\" not \"1\"" << endl;
		return 4;
	} else if (string(header.Subchunk2ID, 4).compare("data")) {
		cerr << "Subchunk2ID was \"" << string(header.Subchunk2ID, 4) << "\" not \"data\"" << endl;
		return 5;
	} else if (header.BitsPerSample != 16) {
		cerr << "BitsPerSample was \"" << header.BitsPerSample << "\" not 16" << endl;
		return 6;
	} else if (header.SampleRate != 44100) {
		cerr << "Sample rate was \"" << header.SampleRate << "\" not 44100 or 16000" << endl;
		return 7;
	} else {
		return 0;
	}
}

int main(int argc, char* argv[])
{
	// Check input arguments
	if (argc != 3) {
		cerr << "Incorrect number of arguments." << endl;
		cerr << "Usage: " << argv[0] << " <source file> <target file>" << endl;
		return 1;
	}

	// Open the input file
	ifstream inputFile(argv[1], ios::in | ios::binary | ios::ate);
	if (!inputFile.is_open()) {
		cerr << "Could not open input file." << endl;
		return 1;
	}

	// Open the output file
	ofstream outputFile(argv[2], ios::out | ios::binary | ios::trunc);
	if (!outputFile.is_open()) {
		cerr << "Could not open output file." << endl;
		return 1;
	}

	// Read the header information
	wave_header header;
	inputFile.seekg(0, ios::beg);
	inputFile.read((char*)&header, sizeof(header));

	// Check the header info
	int error = checkHeader(header);
	if (error > 0) {
		return error;
	}

	// Write the new header
	outputFile.seekp(0, ios::beg);
	outputFile.write((char*)&header, sizeof(header));

	// Calculate the number of sample sets
	unsigned int numSamples = (header.Subchunk2Size / 2) / header.NumChannels;

	// Initialize the filter
	short** x = new short*[header.NumChannels];
	short** y = new short*[header.NumChannels];

	for (int i = 0; i < header.NumChannels; i++) {
		x[i] = new short[NB];
		y[i] = new short[NB];

		for (int j = 0; j < NB; j++) {
			x[i][j] = 0;
			y[i][j] = 0;
		}
	}

	// Seek to the beginning of the samples
	inputFile.seekg(44, ios::beg);
	outputFile.seekp(44, ios::beg);

	// Mark the start time
	clock_t startTime = clock();

	// Do the filtering
	short* sampleSet = new short[header.NumChannels];
	for (unsigned int i = 0; i < numSamples; i++) {
		// Read in a set of samples
		inputFile.read((char*)sampleSet, header.NumChannels * 2);

		// Process each channel that was read
		for (int j = 0; j < header.NumChannels; j++) {
			xiir_filter(x[j], y[j], sampleSet[j]);
			sampleSet[j] = y[j][0];
		}

		// Write out the sample set
		outputFile.write((char*)sampleSet, header.NumChannels * 2);
	}
	
	// Delete the sample set
	delete[] sampleSet;

	// Mark the end time
	clock_t endTime = clock();

	// Delete the filter
	for (int i = 0; i < header.NumChannels; i++) {
		delete [] x[i];
		delete [] y[i];
	}
	delete [] x;
	delete [] y;

	// Output results
	cout << "Filtering time: " << setprecision(4) << fixed << (float)(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;

	// Close the files
	inputFile.close();
	outputFile.close();

	return 0;
}

